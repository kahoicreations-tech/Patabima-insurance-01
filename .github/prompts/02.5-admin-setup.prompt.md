---
mode: agent
title: "Motor Insurance Admin Interface Setup"
phase: "Backend Phase 2.5"
priority: "high"
dependencies: ["01-database-setup", "02-api-endpoints"]
---

# Task: Create Comprehensive Admin Interface for Motor Insurance System

## Objective
Create a comprehensive Django admin interface that enables complete management of the motor insurance system, including categories, pricing, underwriters, quotations, and system monitoring.

## Requirements

### 1. Admin Models to Configure

#### Core Insurance Models Admin
- `MotorCategoryAdmin` - Manage main insurance categories
- `MotorSubcategoryAdmin` - Manage specific products within categories (including extendible variants)
- `MotorPricingAdmin` - Manage base pricing with bracket support
- `ExtendiblePricingAdmin` - Manage extendible product pricing and extension rules
- `CommercialTonnagePricingAdmin` - Manage tonnage-based pricing
- `PsvPllPricingAdmin` - Manage PSV Personal Liability Limit pricing
- `UnderwriterAdmin` - Manage insurance companies and capabilities
- `VehicleAdjustmentFactorsAdmin` - Manage age, usage factors
- `AdditionalFieldPricingAdmin` - Manage tonnage, passenger pricing

#### User & Authentication Models Admin
- `UserAdmin` - Enhanced user management with insurance-specific fields
- `AgentProfileAdmin` - Manage insurance agent profiles and permissions
- `CustomerProfileAdmin` - Manage customer profiles and quotation history

#### Business Process Models Admin
- `QuotationAdmin` - Manage insurance quotations with detailed views
- `ExtendibleQuotationAdmin` - Manage extendible quotations and extension tracking
- `PolicyAdmin` - Manage active policies and renewals
- `PolicyExtensionAdmin` - Manage policy extensions from partial to full coverage
- `ClaimsAdmin` - Manage insurance claims processing
- `PaymentAdmin` - Manage payment transactions and status
- `ExtensionReminderAdmin` - Manage automated reminders for policy extensions

### 2. Enhanced Admin Features

#### Advanced Filtering & Search
```python
class MotorSubcategoryAdmin(admin.ModelAdmin):
    list_display = ['subcategory_name', 'category', 'product_type', 'pricing_model', 'is_active', 'created_at']
    list_filter = ['category', 'product_type', 'pricing_model', 'is_active', 'created_at']
    search_fields = ['subcategory_name', 'subcategory_code', 'category__category_name']
    ordering = ['category', 'subcategory_name']
    list_per_page = 25
    date_hierarchy = 'created_at'
```

#### Inline Editing for Related Models
```python
class SubcategoryInline(admin.TabularInline):
    model = MotorSubcategory
    extra = 1
    fields = ['subcategory_code', 'subcategory_name', 'product_type', 'pricing_model', 'is_active']

class MotorCategoryAdmin(admin.ModelAdmin):
    inlines = [SubcategoryInline]
    list_display = ['category_name', 'category_code', 'subcategory_count', 'is_active']
```

#### Custom Admin Actions with Complete Pricing Control
```python
def activate_selected_products(modeladmin, request, queryset):
    queryset.update(is_active=True)
    messages.success(request, f'{queryset.count()} products activated successfully.')

def deactivate_selected_products(modeladmin, request, queryset):
    queryset.update(is_active=False)
    messages.warning(request, f'{queryset.count()} products deactivated.')

def clone_pricing_to_underwriter(modeladmin, request, queryset):
    """Clone selected pricing to another underwriter with optional adjustments"""
    if 'apply' in request.POST:
        target_underwriter_id = request.POST.get('target_underwriter')
        adjustment_percentage = float(request.POST.get('adjustment_percentage', 0))
        
        target_underwriter = Underwriter.objects.get(id=target_underwriter_id)
        
        for pricing in queryset:
            new_pricing = MotorPricing.objects.create(
                subcategory=pricing.subcategory,
                underwriter=target_underwriter,
                pricing_type=pricing.pricing_type,
                base_rate=pricing.base_rate * (1 + adjustment_percentage/100),
                flat_rate=pricing.flat_rate * (1 + adjustment_percentage/100) if pricing.flat_rate else None,
                rate_per_thousand=pricing.rate_per_thousand * (1 + adjustment_percentage/100) if pricing.rate_per_thousand else None,
                percentage_rate=pricing.percentage_rate,
                min_sum_insured=pricing.min_sum_insured,
                max_sum_insured=pricing.max_sum_insured,
                pricing_brackets=pricing.pricing_brackets,
                tonnage_brackets=pricing.tonnage_brackets,
                tonnage_rates=pricing.tonnage_rates,
                effective_date=timezone.now().date(),
                is_active=True
            )
        
        messages.success(request, f'Cloned {queryset.count()} pricing entries to {target_underwriter.company_name}')
        return HttpResponseRedirect(request.get_full_path())
    
    # Show form for underwriter selection and adjustment
    return render(request, 'admin/clone_pricing_form.html', {
        'queryset': queryset,
        'underwriters': Underwriter.objects.filter(is_active=True),
        'action_checkbox_name': admin.ACTION_CHECKBOX_NAME,
    })

def bulk_update_rates_by_percentage(modeladmin, request, queryset):
    """Update base rates, flat rates, or other pricing fields by percentage"""
    if 'apply' in request.POST:
        field_to_update = request.POST.get('pricing_field')
        percentage_change = float(request.POST.get('percentage_change'))
        
        for pricing in queryset:
            if field_to_update == 'base_rate' and pricing.base_rate:
                pricing.base_rate = pricing.base_rate * (1 + percentage_change/100)
            elif field_to_update == 'flat_rate' and pricing.flat_rate:
                pricing.flat_rate = pricing.flat_rate * (1 + percentage_change/100)
            elif field_to_update == 'rate_per_thousand' and pricing.rate_per_thousand:
                pricing.rate_per_thousand = pricing.rate_per_thousand * (1 + percentage_change/100)
            
            pricing.save()
        
        messages.success(request, f'Updated {field_to_update} for {queryset.count()} pricing entries by {percentage_change}%')
        return HttpResponseRedirect(request.get_full_path())
    
    return render(request, 'admin/bulk_rate_update_form.html', {
        'queryset': queryset,
        'pricing_fields': ['base_rate', 'flat_rate', 'rate_per_thousand', 'percentage_rate'],
        'action_checkbox_name': admin.ACTION_CHECKBOX_NAME,
    })

def create_competitive_pricing(modeladmin, request, queryset):
    """Create competitive pricing based on existing market rates"""
    if 'apply' in request.POST:
        target_underwriter_id = request.POST.get('target_underwriter')
        competitiveness = request.POST.get('competitiveness')  # 'aggressive', 'moderate', 'conservative'
        
        adjustment_map = {
            'aggressive': -15,  # 15% below market
            'moderate': -8,     # 8% below market
            'conservative': -3  # 3% below market
        }
        
        adjustment = adjustment_map.get(competitiveness, -5)
        
        # Implementation logic here
        messages.success(request, f'Created {competitiveness} pricing for selected products')
        return HttpResponseRedirect(request.get_full_path())
    
    return render(request, 'admin/competitive_pricing_form.html', {
        'queryset': queryset,
        'underwriters': Underwriter.objects.filter(is_active=True),
        'action_checkbox_name': admin.ACTION_CHECKBOX_NAME,
    })

def export_pricing_template(modeladmin, request, queryset):
    """Export pricing data as template for bulk import"""
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = 'attachment; filename="pricing_template.csv"'
    
    writer = csv.writer(response)
    writer.writerow([
        'Subcategory Code', 'Underwriter', 'Pricing Type', 'Base Rate', 'Flat Rate',
        'Rate Per Thousand', 'Percentage Rate', 'Min Sum Insured', 'Max Sum Insured',
        'Effective Date', 'Is Active'
    ])
    
    for pricing in queryset:
        writer.writerow([
            pricing.subcategory.subcategory_code,
            pricing.underwriter.company_name,
            pricing.pricing_type,
            pricing.base_rate,
            pricing.flat_rate,
            pricing.rate_per_thousand,
            pricing.percentage_rate,
            pricing.min_sum_insured,
            pricing.max_sum_insured,
            pricing.effective_date,
            pricing.is_active
        ])
    
    return response
```

#### Rich Admin Interface with Dynamic Pricing Control
```python
class MotorPricingAdmin(admin.ModelAdmin):
    list_display = ['subcategory', 'underwriter', 'pricing_type', 'base_rate', 'flat_rate', 'min_sum_insured', 'max_sum_insured', 'effective_date', 'is_active']
    list_filter = ['underwriter', 'subcategory__category', 'pricing_type', 'effective_date', 'is_active']
    search_fields = ['subcategory__subcategory_name', 'underwriter__company_name']
    readonly_fields = ['created_at', 'updated_at', 'pricing_id']
    list_editable = ['base_rate', 'flat_rate', 'is_active']  # Quick edit capabilities
    
    fieldsets = (
        ('Basic Information', {
            'fields': ('subcategory', 'underwriter', 'pricing_type', 'effective_date', 'is_active')
        }),
        ('Dynamic Pricing Configuration', {
            'fields': ('base_rate', 'flat_rate', 'rate_per_thousand', 'percentage_rate'),
            'description': 'Configure pricing rates that can vary by underwriter'
        }),
        ('Sum Insured Brackets (For Comprehensive)', {
            'fields': ('min_sum_insured', 'max_sum_insured', 'pricing_brackets'),
            'classes': ('collapse',)
        }),
        ('Tonnage Pricing (For Commercial)', {
            'fields': ('tonnage_brackets', 'tonnage_rates'),
            'classes': ('collapse',)
        }),
        ('PSV Pricing (For Public Service Vehicles)', {
            'fields': ('pll_rate_500', 'pll_rate_250', 'passenger_rate'),
            'classes': ('collapse',)
        }),
        ('Advanced Pricing Factors', {
            'fields': ('age_adjustment_factors', 'usage_multipliers', 'regional_factors'),
            'classes': ('collapse',)
        }),
        ('Metadata', {
            'fields': ('created_at', 'updated_at', 'pricing_id'),
            'classes': ('collapse',)
        })
    )
    
    def get_form(self, request, obj=None, **kwargs):
        form = super().get_form(request, obj, **kwargs)
        # Add dynamic help text based on pricing type
        if obj and obj.pricing_type:
            form.base.fields['base_rate'].help_text = f"Base rate for {obj.pricing_type} pricing"
        return form
```

### 2.5. Extendible Product Management

#### ExtendiblePricingAdmin - Manage Partial Payment Products
```python
class ExtendiblePricingAdmin(admin.ModelAdmin):
    list_display = ['subcategory', 'underwriter', 'initial_period_days', 'initial_amount', 
                   'balance_amount', 'total_annual_premium', 'extension_deadline_days', 'is_active']
    list_filter = ['subcategory__category', 'underwriter', 'initial_period_days', 'is_active']
    search_fields = ['subcategory__subcategory_name', 'underwriter__company_name']
    list_editable = ['initial_amount', 'balance_amount', 'extension_deadline_days', 'is_active']
    
    fieldsets = (
        ('Product Information', {
            'fields': ('subcategory', 'underwriter', 'is_active')
        }),
        ('Initial Coverage Period', {
            'fields': ('initial_period_days', 'initial_amount', 'cover_note_template'),
            'description': 'Configure the partial payment period (e.g., 30 days for KSh 1,500)'
        }),
        ('Extension Configuration', {
            'fields': ('balance_amount', 'total_annual_premium', 'extension_deadline_days', 'grace_period_days'),
            'description': 'Configure the balance payment and extension rules'
        }),
        ('Document Templates', {
            'fields': ('cover_note_template', 'full_certificate_template', 'extension_reminder_template'),
            'classes': ('collapse',)
        }),
        ('Business Rules', {
            'fields': ('auto_reminder_schedule', 'penalty_for_late_extension', 'allow_partial_extension'),
            'classes': ('collapse',)
        })
    )
    
    actions = ['create_extendible_variants', 'update_extension_rates', 'generate_reminder_schedule']
    
    def create_extendible_variants(self, request, queryset):
        """Create extendible variants for regular products"""
        created_count = 0
        for pricing in queryset:
            # Create extendible variant if it doesn't exist
            subcategory_name = f"{pricing.subcategory.subcategory_name} Extendible"
            extendible_subcategory, created = MotorSubcategory.objects.get_or_create(
                category=pricing.subcategory.category,
                subcategory_code=f"{pricing.subcategory.subcategory_code}_ext",
                subcategory_name=subcategory_name,
                defaults={
                    'product_type': pricing.subcategory.product_type,
                    'pricing_model': 'extendible',
                    'is_extendible': True,
                    'additional_fields': pricing.subcategory.additional_fields
                }
            )
            
            if created:
                # Create extendible pricing
                ExtendiblePricing.objects.create(
                    subcategory=extendible_subcategory,
                    underwriter=pricing.underwriter,
                    initial_period_days=30,  # 1 month default
                    initial_amount=1500,     # Default initial amount
                    balance_amount=2000,     # Default balance
                    total_annual_premium=3500,  # Default total
                    extension_deadline_days=30,
                    grace_period_days=7,
                    is_active=True
                )
                created_count += 1
        
        messages.success(request, f'Created {created_count} extendible product variants')
    
    create_extendible_variants.short_description = "Create extendible variants for selected products"

class PolicyExtensionAdmin(admin.ModelAdmin):
    list_display = ['policy_number', 'customer_name', 'product_name', 'initial_expiry_date', 
                   'extension_status', 'balance_amount', 'reminder_count', 'days_remaining']
    list_filter = ['extension_status', 'initial_expiry_date', 'created_at']
    search_fields = ['policy_number', 'customer_name', 'product_name']
    readonly_fields = ['days_remaining', 'reminder_count', 'last_reminder_sent']
    
    fieldsets = (
        ('Policy Information', {
            'fields': ('policy_number', 'customer_name', 'product_name', 'underwriter')
        }),
        ('Extension Status', {
            'fields': ('extension_status', 'initial_expiry_date', 'balance_amount', 'days_remaining')
        }),
        ('Reminder Management', {
            'fields': ('reminder_count', 'last_reminder_sent', 'auto_reminder_enabled'),
        }),
        ('Extension History', {
            'fields': ('extension_payment_date', 'extension_amount_paid', 'full_certificate_issued'),
            'classes': ('collapse',)
        })
    )
    
    actions = ['send_extension_reminders', 'process_manual_extensions', 'generate_cover_notes']
    
    def send_extension_reminders(self, request, queryset):
        """Send extension reminders to customers"""
        sent_count = 0
        for extension in queryset.filter(extension_status='pending'):
            # Logic to send reminder (SMS, email, app notification)
            extension.reminder_count += 1
            extension.last_reminder_sent = timezone.now()
            extension.save()
            sent_count += 1
        
        messages.success(request, f'Sent extension reminders to {sent_count} customers')
    
    send_extension_reminders.short_description = "Send extension reminders"
    
    def days_remaining(self, obj):
        if obj.initial_expiry_date:
            remaining = (obj.initial_expiry_date - timezone.now().date()).days
            if remaining < 0:
                return format_html('<span style="color: red;">Expired {} days ago</span>', abs(remaining))
            elif remaining <= 7:
                return format_html('<span style="color: orange;">{} days</span>', remaining)
            else:
                return f'{remaining} days'
        return 'N/A'
    
    days_remaining.short_description = 'Days to Expiry'

class ExtensionReminderAdmin(admin.ModelAdmin):
    list_display = ['policy_extension', 'reminder_type', 'scheduled_date', 'sent_date', 'status', 'customer_response']
    list_filter = ['reminder_type', 'status', 'scheduled_date', 'sent_date']
    search_fields = ['policy_extension__policy_number', 'policy_extension__customer_name']
    readonly_fields = ['sent_date', 'delivery_status', 'customer_response_date']
    
    fieldsets = (
        ('Reminder Details', {
            'fields': ('policy_extension', 'reminder_type', 'scheduled_date', 'message_template')
        }),
        ('Delivery Status', {
            'fields': ('status', 'sent_date', 'delivery_status', 'delivery_channel')
        }),
        ('Customer Response', {
            'fields': ('customer_response', 'customer_response_date', 'follow_up_required'),
            'classes': ('collapse',)
        })
    )
    
    actions = ['reschedule_reminders', 'mark_as_sent', 'generate_follow_up_tasks']
```

### 3. Dashboard & Analytics

#### Custom Admin Dashboard
```python
class MotorInsuranceAdminSite(admin.AdminSite):
    site_header = 'PataBima Motor Insurance Administration'
    site_title = 'PataBima Admin'
    index_title = 'Motor Insurance Management Dashboard'
    
    def index(self, request, extra_context=None):
        extra_context = extra_context or {}
        
        # Dashboard statistics
        extra_context.update({
            'total_categories': MotorCategory.objects.count(),
            'total_subcategories': MotorSubcategory.objects.count(),
            'active_underwriters': Underwriter.objects.filter(is_active=True).count(),
            'pending_quotations': Quotation.objects.filter(status='pending').count(),
            'recent_quotations': Quotation.objects.order_by('-created_at')[:5],
            'pricing_updates_needed': self._get_pricing_updates_needed(),
        })
        
        return super().index(request, extra_context)
```

#### Admin Statistics Widgets
```python
def _get_pricing_updates_needed(self):
    """Get pricing entries that may need updates"""
    from datetime import datetime, timedelta
    six_months_ago = datetime.now() - timedelta(days=180)
    return MotorPricing.objects.filter(
        updated_at__lt=six_months_ago,
        is_active=True
    ).count()
```

### 4. Data Management Tools

#### Import/Export Functionality
```python
class MotorPricingAdmin(ImportExportModelAdmin):
    resource_class = MotorPricingResource
    
    def get_export_formats(self):
        formats = (CSV, XLSX)
        return [f for f in formats if f().can_export()]
    
    def get_import_formats(self):
        formats = (CSV, XLSX)
        return [f for f in formats if f().can_import()]
```

#### Bulk Operations with Dynamic Pricing Control
```python
class BulkPricingUpdateForm(forms.Form):
    PRICING_FIELDS = [
        ('base_rate', 'Base Rate'),
        ('flat_rate', 'Flat Rate'),
        ('rate_per_thousand', 'Rate per Thousand'),
        ('percentage_rate', 'Percentage Rate'),
    ]
    
    pricing_field = forms.ChoiceField(
        choices=PRICING_FIELDS,
        help_text="Select which pricing field to update"
    )
    
    update_type = forms.ChoiceField(
        choices=[
            ('percentage', 'Percentage Change'),
            ('absolute', 'Absolute Value'),
            ('add', 'Add Amount'),
            ('multiply', 'Multiply by Factor')
        ],
        help_text="How to apply the update"
    )
    
    value = forms.DecimalField(
        max_digits=10, 
        decimal_places=2,
        help_text="Value to apply (e.g., 5.00 for 5% increase, or 1000.00 for absolute rate)"
    )
    
    effective_date = forms.DateField(
        widget=forms.DateInput(attrs={'type': 'date'}),
        help_text="Date when new pricing becomes effective"
    )
    
    underwriters = forms.ModelMultipleChoiceField(
        queryset=Underwriter.objects.filter(is_active=True),
        widget=forms.CheckboxSelectMultiple,
        required=False,
        help_text="Select specific underwriters (leave empty for all)"
    )
    
    categories = forms.ModelMultipleChoiceField(
        queryset=MotorCategory.objects.all(),
        widget=forms.CheckboxSelectMultiple,
        required=False,
        help_text="Select categories to update (leave empty for all)"
    )
    
    subcategories = forms.ModelMultipleChoiceField(
        queryset=MotorSubcategory.objects.all(),
        widget=forms.CheckboxSelectMultiple,
        required=False,
        help_text="Select specific subcategories (overrides category selection)"
    )

class UnderwriterSpecificPricingForm(forms.Form):
    """Form for setting underwriter-specific pricing across all products"""
    underwriter = forms.ModelChoiceField(
        queryset=Underwriter.objects.filter(is_active=True),
        help_text="Select underwriter to configure pricing for"
    )
    
    pricing_strategy = forms.ChoiceField(
        choices=[
            ('competitive', 'Competitive (5-10% below market)'),
            ('market', 'Market Rate (standard pricing)'),
            ('premium', 'Premium (10-20% above market)'),
            ('custom', 'Custom (specify exact rates)')
        ],
        help_text="Select pricing strategy for this underwriter"
    )
    
    global_adjustment = forms.DecimalField(
        max_digits=5,
        decimal_places=2,
        initial=0,
        help_text="Global percentage adjustment for all products (+/-)"
    )
    
    apply_to_categories = forms.ModelMultipleChoiceField(
        queryset=MotorCategory.objects.all(),
        widget=forms.CheckboxSelectMultiple,
        help_text="Apply to specific categories"
    )
```

### 5. Security & Permissions

#### Role-Based Admin Access
```python
class InsuranceAdminMixin:
    def has_view_permission(self, request, obj=None):
        return request.user.has_perm('insurance.view_motor_data')
    
    def has_change_permission(self, request, obj=None):
        return request.user.has_perm('insurance.change_motor_data')
    
    def has_delete_permission(self, request, obj=None):
        return request.user.has_perm('insurance.delete_motor_data')

class MotorPricingAdmin(InsuranceAdminMixin, admin.ModelAdmin):
    # Admin configuration
    pass
```

#### Admin User Groups
- **Super Admin**: Full access to all models and settings
- **Insurance Manager**: Access to categories, pricing, underwriters
- **Agent Manager**: Access to quotations, policies, agents
- **Customer Service**: Read-only access to quotations and policies
- **Pricing Analyst**: Access to pricing models and analytics

### 6. Monitoring & Logging

#### Admin Action Logging
```python
class AuditableModelAdmin(admin.ModelAdmin):
    def save_model(self, request, obj, form, change):
        if change:
            LogEntry.objects.log_action(
                user_id=request.user.pk,
                content_type_id=ContentType.objects.get_for_model(obj).pk,
                object_id=obj.pk,
                object_repr=str(obj),
                action_flag=CHANGE,
                change_message=f"Updated by {request.user.username}"
            )
        super().save_model(request, obj, form, change)
```

#### System Health Monitoring
```python
class SystemHealthAdmin(admin.ModelAdmin):
    change_list_template = 'admin/system_health.html'
    
    def changelist_view(self, request, extra_context=None):
        extra_context = extra_context or {}
        extra_context.update({
            'database_status': self._check_database_health(),
            'api_status': self._check_api_health(),
            'pricing_integrity': self._check_pricing_integrity(),
        })
        return super().changelist_view(request, extra_context)
```

### 7. Extendible Product Database Models

#### Core Extendible Models
Create the following models to support extendible products:

```python
class ExtendiblePricing(models.Model):
    """Pricing configuration for extendible products"""
    subcategory = models.ForeignKey(MotorSubcategory, on_delete=models.CASCADE)
    underwriter = models.ForeignKey(Underwriter, on_delete=models.CASCADE)
    
    # Initial coverage period configuration
    initial_period_days = models.PositiveIntegerField(default=30, help_text="Initial coverage period in days")
    initial_amount = models.DecimalField(max_digits=10, decimal_places=2, help_text="Amount for initial period")
    
    # Extension configuration
    balance_amount = models.DecimalField(max_digits=10, decimal_places=2, help_text="Balance amount to extend")
    total_annual_premium = models.DecimalField(max_digits=10, decimal_places=2, help_text="Total annual premium")
    extension_deadline_days = models.PositiveIntegerField(default=30, help_text="Days before initial expiry to allow extension")
    grace_period_days = models.PositiveIntegerField(default=7, help_text="Grace period after expiry")
    
    # Document templates
    cover_note_template = models.TextField(blank=True, help_text="Template for cover note")
    full_certificate_template = models.TextField(blank=True, help_text="Template for full certificate")
    extension_reminder_template = models.TextField(blank=True, help_text="Template for extension reminders")
    
    # Business rules
    auto_reminder_schedule = models.JSONField(default=list, help_text="Reminder schedule: [7, 3, 1] days before expiry")
    penalty_for_late_extension = models.DecimalField(max_digits=5, decimal_places=2, default=0, help_text="Penalty percentage for late extension")
    allow_partial_extension = models.BooleanField(default=False, help_text="Allow partial balance payments")
    
    # Metadata
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        unique_together = ['subcategory', 'underwriter']
        verbose_name = 'Extendible Pricing'
        verbose_name_plural = 'Extendible Pricing'

class PolicyExtension(models.Model):
    """Track policy extensions for extendible products"""
    EXTENSION_STATUS_CHOICES = [
        ('pending', 'Pending Extension'),
        ('reminded', 'Reminder Sent'),
        ('extended', 'Successfully Extended'),
        ('expired', 'Expired Without Extension'),
        ('grace_period', 'In Grace Period'),
    ]
    
    policy_number = models.CharField(max_length=50, unique=True)
    customer_name = models.CharField(max_length=200)
    customer_phone = models.CharField(max_length=20)
    customer_email = models.EmailField(blank=True)
    product_name = models.CharField(max_length=200)
    underwriter = models.ForeignKey(Underwriter, on_delete=models.CASCADE)
    
    # Initial policy details
    initial_premium_paid = models.DecimalField(max_digits=10, decimal_places=2)
    initial_start_date = models.DateField()
    initial_expiry_date = models.DateField()
    
    # Extension details
    balance_amount = models.DecimalField(max_digits=10, decimal_places=2)
    extension_status = models.CharField(max_length=20, choices=EXTENSION_STATUS_CHOICES, default='pending')
    reminder_count = models.PositiveIntegerField(default=0)
    last_reminder_sent = models.DateTimeField(null=True, blank=True)
    
    # Extension completion
    extension_payment_date = models.DateTimeField(null=True, blank=True)
    extension_amount_paid = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    full_certificate_issued = models.BooleanField(default=False)
    final_expiry_date = models.DateField(null=True, blank=True)
    
    # Settings
    auto_reminder_enabled = models.BooleanField(default=True)
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    @property
    def days_remaining(self):
        if self.extension_status == 'extended':
            return None
        today = timezone.now().date()
        if self.initial_expiry_date >= today:
            return (self.initial_expiry_date - today).days
        else:
            return -(today - self.initial_expiry_date).days  # Negative for expired
    
    class Meta:
        verbose_name = 'Policy Extension'
        verbose_name_plural = 'Policy Extensions'
        ordering = ['initial_expiry_date']

class ExtensionReminder(models.Model):
    """Track extension reminders sent to customers"""
    REMINDER_TYPES = [
        ('email', 'Email'),
        ('sms', 'SMS'),
        ('app_notification', 'App Notification'),
        ('phone_call', 'Phone Call'),
    ]
    
    STATUS_CHOICES = [
        ('scheduled', 'Scheduled'),
        ('sent', 'Sent'),
        ('delivered', 'Delivered'),
        ('failed', 'Failed'),
        ('responded', 'Customer Responded'),
    ]
    
    policy_extension = models.ForeignKey(PolicyExtension, on_delete=models.CASCADE, related_name='reminders')
    reminder_type = models.CharField(max_length=20, choices=REMINDER_TYPES)
    scheduled_date = models.DateTimeField()
    sent_date = models.DateTimeField(null=True, blank=True)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='scheduled')
    
    # Message details
    message_template = models.TextField()
    personalized_message = models.TextField(blank=True)
    
    # Delivery tracking
    delivery_channel = models.CharField(max_length=100, blank=True)  # Email address, phone number, etc.
    delivery_status = models.CharField(max_length=100, blank=True)   # Provider-specific status
    
    # Customer response
    customer_response = models.TextField(blank=True)
    customer_response_date = models.DateTimeField(null=True, blank=True)
    follow_up_required = models.BooleanField(default=False)
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        verbose_name = 'Extension Reminder'
        verbose_name_plural = 'Extension Reminders'
        ordering = ['scheduled_date']

# Update MotorSubcategory to include extendible flag
class MotorSubcategory(models.Model):
    # ... existing fields ...
    is_extendible = models.BooleanField(default=False, help_text="Can this product be sold as extendible?")
    extendible_variant = models.ForeignKey('self', null=True, blank=True, on_delete=models.SET_NULL, 
                                         help_text="Link to the extendible variant of this product")
    
    # Update pricing_model choices to include 'extendible'
    PRICING_MODEL_CHOICES = [
        ('fixed', 'Fixed Rate'),
        ('bracket', 'Bracket-based'),
        ('tonnage', 'Tonnage-based'),
        ('passenger', 'Passenger-based'),
        ('extendible', 'Extendible Payment'),  # New option
    ]
```

### 8. Extendible Product Workflow Management

#### Automated Extension Processing
```python
class ExtensionWorkflowAdmin(admin.ModelAdmin):
    """Manage the automated workflow for extendible products"""
    list_display = ['workflow_name', 'trigger_days_before', 'action_type', 'is_active', 'last_run']
    list_filter = ['action_type', 'is_active', 'trigger_days_before']
    
    actions = ['run_extension_workflow', 'test_reminder_templates']
    
    def run_extension_workflow(self, request, queryset):
        """Manually trigger extension workflows"""
        processed = 0
        for workflow in queryset.filter(is_active=True):
            # Find policies that match workflow criteria
            target_date = timezone.now().date() + timedelta(days=workflow.trigger_days_before)
            policies = PolicyExtension.objects.filter(
                initial_expiry_date=target_date,
                extension_status='pending',
                auto_reminder_enabled=True
            )
            
            for policy in policies:
                if workflow.action_type == 'send_reminder':
                    # Create reminder
                    ExtensionReminder.objects.create(
                        policy_extension=policy,
                        reminder_type=workflow.reminder_type,
                        scheduled_date=timezone.now(),
                        message_template=workflow.message_template
                    )
                    processed += 1
        
        messages.success(request, f'Processed {processed} extension workflows')
    
    run_extension_workflow.short_description = "Run selected extension workflows"
```
```

## Success Criteria
- [ ] All motor insurance models have comprehensive admin interfaces with **complete pricing control**
- [ ] **Dynamic rate management** - Admin can change base rates, flat rates, percentage rates per underwriter
- [ ] **Underwriter-specific pricing** - Each underwriter can have different rates for the same product
- [ ] **Extendible product management** - Full support for partial payment products with extension tracking
- [ ] **Extension workflow automation** - Automated reminders and policy extension processing
- [ ] **Cover note and certificate management** - Document generation for extendible products
- [ ] Advanced filtering and search functionality implemented
- [ ] Inline editing for related models configured
- [ ] **Bulk pricing operations** - Mass updates, competitive pricing, rate cloning
- [ ] Custom admin actions for **rate management** and **underwriter pricing strategies**
- [ ] Dashboard with key statistics and **pricing analytics** implemented
- [ ] Import/export functionality for **bulk pricing updates** working
- [ ] **Role-based permissions** for pricing management properly configured
- [ ] Admin logging and audit trail for **all pricing changes** functional
- [ ] System health monitoring dashboard created
- [ ] **Pricing template generation** and **competitive analysis tools** working
- [ ] **Extendible product creation tools** - Generate extendible variants from regular products
- [ ] **Extension reminder system** - Automated SMS/email/app notifications for policy extensions
- [ ] **Policy extension tracking** - Monitor customers who need to complete balance payments
- [ ] User-friendly admin interface with **pricing-specific help text**

## Technical Implementation

### 1. Enhanced Model Admins with Complete Pricing Control
Create comprehensive admin classes in `apps/insurance/admin.py`:

```python
# Dynamic Pricing Management with Full Admin Control
@admin.register(MotorPricing)
class MotorPricingAdmin(ImportExportModelAdmin):
    list_display = [
        'subcategory', 'underwriter', 'pricing_type', 'base_rate', 'flat_rate', 
        'rate_per_thousand', 'percentage_rate', 'effective_date', 'is_active', 'last_updated_by'
    ]
    list_filter = [
        'underwriter', 'subcategory__category', 'pricing_type', 'is_active', 
        'effective_date', 'updated_at'
    ]
    search_fields = [
        'subcategory__subcategory_name', 'underwriter__company_name',
        'subcategory__subcategory_code'
    ]
    date_hierarchy = 'effective_date'
    list_editable = ['base_rate', 'flat_rate', 'rate_per_thousand', 'is_active']
    actions = [
        'activate_pricing', 'deactivate_pricing', 'clone_pricing_to_underwriter',
        'bulk_update_rates_by_percentage', 'create_competitive_pricing',
        'export_pricing_template', 'duplicate_for_new_period'
    ]
    
    fieldsets = (
        ('Product Information', {
            'fields': ('subcategory', 'underwriter', 'pricing_type', 'effective_date', 'is_active')
        }),
        ('Core Pricing Rates (Admin Configurable)', {
            'fields': ('base_rate', 'flat_rate', 'rate_per_thousand', 'percentage_rate'),
            'description': 'All rates can be dynamically set per underwriter. Admin has full control.'
        }),
        ('Comprehensive Product Pricing', {
            'fields': ('min_sum_insured', 'max_sum_insured', 'pricing_brackets'),
            'classes': ('collapse',),
            'description': 'Bracket-based pricing for comprehensive coverage'
        }),
        ('Commercial Tonnage Pricing', {
            'fields': ('tonnage_brackets', 'tonnage_rates'),
            'classes': ('collapse',),
            'description': 'Weight-based pricing rates for commercial vehicles'
        }),
        ('PSV & Passenger Pricing', {
            'fields': ('pll_rate_500', 'pll_rate_250', 'passenger_base_rate', 'passenger_increment'),
            'classes': ('collapse',),
            'description': 'Per-passenger and PLL pricing for public service vehicles'
        }),
        ('Advanced Pricing Factors', {
            'fields': ('age_factors', 'usage_multipliers', 'regional_adjustments', 'seasonal_factors'),
            'classes': ('collapse',),
            'description': 'Additional factors that can be configured per underwriter'
        }),
        ('Pricing History & Audit', {
            'fields': ('created_at', 'updated_at', 'last_updated_by', 'change_reason'),
            'classes': ('collapse',)
        })
    )
    
    def save_model(self, request, obj, form, change):
        obj.last_updated_by = request.user
        if change:
            obj.change_reason = f"Updated by {request.user.username} on {timezone.now()}"
        super().save_model(request, obj, form, change)

# Underwriter Management with Pricing Overview
@admin.register(Underwriter)
class UnderwriterAdmin(admin.ModelAdmin):
    list_display = [
        'company_name', 'company_code', 'contact_person', 'pricing_count', 
        'average_competitiveness', 'is_active', 'last_pricing_update'
    ]
    list_filter = ['is_active', 'created_at']
    search_fields = ['company_name', 'company_code', 'contact_person', 'email']
    inlines = [UnderwriterPricingInline]
    actions = ['create_full_pricing_matrix', 'update_all_pricing_by_percentage']
    
    fieldsets = (
        ('Company Information', {
            'fields': ('company_name', 'company_code', 'logo', 'is_active')
        }),
        ('Contact Details', {
            'fields': ('contact_person', 'email', 'phone', 'address')
        }),
        ('Pricing Configuration', {
            'fields': ('default_markup_percentage', 'competitive_strategy', 'pricing_tier'),
            'description': 'Default pricing behavior for this underwriter'
        }),
        ('Business Rules', {
            'fields': ('supported_categories', 'max_sum_insured', 'min_premium', 'terms_conditions'),
            'classes': ('collapse',)
        })
    )
    
    def pricing_count(self, obj):
        return obj.pricing_entries.count()
    pricing_count.short_description = 'Active Pricing Rules'
    
    def average_competitiveness(self, obj):
        # Calculate average pricing compared to market
        return "Market Average"  # Implement calculation logic
    
    def last_pricing_update(self, obj):
        latest = obj.pricing_entries.order_by('-updated_at').first()
        return latest.updated_at if latest else "Never"

# Category Management with Pricing Overview
@admin.register(MotorCategory)
class MotorCategoryAdmin(admin.ModelAdmin):
    list_display = [
        'category_name', 'category_code', 'subcategory_count', 
        'total_pricing_rules', 'price_range_display', 'is_active', 'created_at'
    ]
    list_filter = ['is_active', 'created_at']
    search_fields = ['category_name', 'category_code']
    inlines = [SubcategoryInline]
    actions = ['create_pricing_for_all_underwriters', 'update_category_pricing']
    
    def subcategory_count(self, obj):
        return obj.subcategories.count()
    subcategory_count.short_description = 'Subcategories'
    
    def total_pricing_rules(self, obj):
        return sum(sub.pricing_entries.count() for sub in obj.subcategories.all())
    total_pricing_rules.short_description = 'Total Pricing Rules'
    
    def price_range_display(self, obj):
        # Calculate min/max pricing across all subcategories
        prices = []
        for sub in obj.subcategories.all():
            for pricing in sub.pricing_entries.filter(is_active=True):
                if pricing.base_rate:
                    prices.append(pricing.base_rate)
                if pricing.flat_rate:
                    prices.append(pricing.flat_rate)
        
        if prices:
            return f"KSh {min(prices):,.0f} - KSh {max(prices):,.0f}"
        return "No pricing set"
    price_range_display.short_description = 'Price Range'
```

### 2. Custom Admin Templates
Create custom templates in `templates/admin/`:
- `base_site.html` - Custom admin base template
- `index.html` - Dashboard with statistics
- `system_health.html` - System monitoring page
- `bulk_operations.html` - Bulk operation forms

### 3. Admin Configuration
Update `settings.py` with admin customizations:
```python
ADMIN_SITE_HEADER = 'PataBima Motor Insurance Administration'
ADMIN_SITE_TITLE = 'PataBima Admin'
ADMIN_INDEX_TITLE = 'Motor Insurance Management'

# Enable admin documentation
INSTALLED_APPS += ['django.contrib.admindocs']
```

## Files to Create/Modify

### Primary Files
- `apps/insurance/admin.py` - Main admin configuration with **dynamic pricing management**
- `apps/insurance/admin_views.py` - Custom admin views for **pricing analysis**
- `apps/insurance/admin_forms.py` - Custom admin forms for **bulk pricing operations**
- `apps/insurance/resources.py` - Import/export resources for **pricing data**
- `apps/insurance/pricing_utils.py` - **Pricing calculation utilities** for admin
- `apps/insurance/pricing_templates.py` - **Template generation** for pricing imports
- `apps/insurance/extendible_admin.py` - **Extendible product admin configurations**
- `apps/insurance/extension_workflows.py` - **Automated extension processing**

### Models Enhancement
- `apps/insurance/models.py` - Add **ExtendiblePricing**, **PolicyExtension**, **ExtensionReminder** models
- `apps/insurance/migrations/` - Database migrations for **extendible functionality**

### Template Files
- `templates/admin/base_site.html` - Custom admin base template
- `templates/admin/insurance/dashboard.html` - Dashboard with **pricing statistics**
- `templates/admin/insurance/pricing_analytics.html` - **Pricing analytics and comparisons**
- `templates/admin/insurance/bulk_operations.html` - **Bulk pricing operation forms**
- `templates/admin/clone_pricing_form.html` - **Underwriter pricing cloning**
- `templates/admin/competitive_pricing_form.html` - **Competitive pricing setup**
- `templates/admin/bulk_rate_update_form.html` - **Bulk rate update interface**
- `templates/admin/extendible_products.html` - **Extendible product management**
- `templates/admin/extension_reminders.html` - **Extension reminder management**
- `templates/admin/policy_extensions.html` - **Policy extension tracking**

### Static Files
- `static/admin/css/custom_admin.css` - Custom admin styling
- `static/admin/css/pricing_admin.css` - **Pricing-specific admin styles**
- `static/admin/css/extendible_admin.css` - **Extendible product admin styles**
- `static/admin/js/admin_enhancements.js` - General admin enhancements
- `static/admin/js/pricing_calculator.js` - **Real-time pricing calculations**
- `static/admin/js/bulk_pricing.js` - **Bulk pricing operation helpers**
- `static/admin/js/extension_workflows.js` - **Extension workflow management**

### Business Logic Files
- `apps/insurance/services/extension_service.py` - **Extension processing business logic**
- `apps/insurance/services/reminder_service.py` - **Automated reminder system**
- `apps/insurance/tasks/extension_tasks.py` - **Celery tasks for extension automation**
- `apps/insurance/utils/extendible_utils.py` - **Extendible product utilities**

## Extendible Product Business Examples

### Example 1: Private Third-Party Extendible
**Product**: Private Third-Party Extendible
**Scenario**: Customer wants insurance but can only afford partial payment

**Admin Configuration**:
- Initial Period: 30 days
- Initial Amount: KSh 1,500
- Balance Amount: KSh 2,000  
- Total Annual Premium: KSh 3,500
- Extension Deadline: 30 days before expiry
- Grace Period: 7 days after expiry

**Customer Journey**:
1. **Day 1**: Customer pays KSh 1,500 → Receives 30-day cover note
2. **Day 7**: System sends first reminder about balance payment
3. **Day 15**: Second reminder with balance due (KSh 2,000)
4. **Day 25**: Final reminder - 5 days to pay balance
5. **Day 30**: If paid → Full certificate issued; If not → Grace period starts
6. **Day 37**: Grace period ends → Policy lapses if still unpaid

### Example 2: Commercial Comprehensive Extendible
**Product**: Commercial Comprehensive Extendible
**Vehicle**: 5-ton truck valued at KSh 2,000,000

**Admin Configuration**:
- Initial Period: 60 days (longer for commercial)
- Initial Amount: KSh 15,000
- Balance Amount: KSh 25,000
- Total Annual Premium: KSh 40,000
- Extension Deadline: 45 days before expiry
- Grace Period: 14 days (longer for commercial)

**Business Logic**:
- Higher initial amounts for commercial vehicles
- Longer grace periods for business customers
- Multiple reminder channels (SMS, email, phone calls)
- Option for partial balance payments

### Example 3: PSV Comprehensive Extendible
**Product**: PSV Comprehensive Extendible
**Vehicle**: 14-seater matatu

**Admin Configuration**:
- Initial Period: 30 days
- Initial Amount: KSh 8,000
- Balance Amount: KSh 12,000
- Total Annual Premium: KSh 20,000
- Extension Deadline: 30 days before expiry
- Grace Period: 10 days

**Special Features**:
- PSV licensing compliance tracking
- NTSA integration for route permits
- Enhanced reminder system for compliance deadlines

### Admin Workflow for Creating Extendible Products

#### Step 1: Create Base Product
1. Navigate to Motor Subcategories
2. Create regular product (e.g., "Private Third-Party")
3. Configure normal pricing

#### Step 2: Create Extendible Variant
1. Use "Create Extendible Variants" action
2. System auto-creates subcategory with "_Extendible" suffix
3. Links original and extendible products

#### Step 3: Configure Extendible Pricing
1. Navigate to Extendible Pricing admin
2. Set initial period, amounts, and deadlines
3. Configure reminder templates and schedules
4. Set business rules (grace periods, penalties)

#### Step 4: Monitor Extensions
1. Use Policy Extension admin to track customer status
2. Send manual reminders when needed
3. Process extensions when payments received
4. Generate certificates and update policy status

## Testing Requirements
- [ ] Test all admin interfaces load correctly with **pricing data**
- [ ] Verify filtering and search functionality for **underwriter-specific pricing**
- [ ] Test **extendible product creation** and variant generation
- [ ] Validate **extension reminder system** with multiple channels
- [ ] Test **policy extension workflow** from partial to full coverage
- [ ] Verify **cover note and certificate generation** for extendible products
- [ ] Test bulk operations and custom actions for **rate management**
- [ ] Validate import/export functionality for **pricing templates**
- [ ] Test **dynamic pricing updates** across different underwriters
- [ ] Test role-based permissions for **pricing access control**
- [ ] Verify admin logging and audit trails for **all pricing changes**
- [ ] Test dashboard statistics accuracy for **pricing analytics**
- [ ] Test **competitive pricing algorithms** and rate calculations
- [ ] Validate **bulk pricing operations** with different scenarios
- [ ] Test **pricing cloning** between underwriters
- [ ] Verify **rate template generation** and import workflows

## Security Considerations
- Implement proper user authentication and authorization
- Use Django's built-in admin security features
- Log all administrative actions
- Implement session timeouts for admin users
- Use HTTPS for admin interface access
- Regular security audits of admin permissions

## Performance Optimization
- Optimize admin queries with select_related and prefetch_related
- Implement pagination for large datasets
- Use caching for frequently accessed admin data
- Optimize admin static files loading

## Next Steps After Completion
This comprehensive admin interface enables:
- **Complete pricing control** - Admin can modify any rate for any underwriter
- **Dynamic rate management** - Real-time pricing updates across the system
- **Extendible product management** - Full support for partial payment products with automated extensions
- **Extension workflow automation** - Automated reminders, grace periods, and certificate generation
- **Competitive pricing strategies** - Tools to create market-competitive rates
- **Bulk pricing operations** - Mass updates, cloning, and template-based imports
- **Underwriter-specific pricing** - Each insurance company can have unique rates
- **Pricing analytics** - Dashboard insights into rate competitiveness
- **Data import/export** - Seamless pricing data management
- **Audit trails** - Complete tracking of all pricing changes
- **Role-based access** - Secure pricing management for different user levels
- **System monitoring** - Health checks and pricing integrity validation
- **Customer journey management** - Track extendible policies from partial to full coverage
- **Reminder system automation** - Multi-channel notifications for policy extensions
- **Certificate generation** - Automated cover notes and full certificates for extendible products
- **Preparation for Prompt 03** - Frontend integration with fully managed backend
- **Production-ready administrative capabilities** with complete pricing flexibility

## Usage Documentation
Create comprehensive admin user guide covering:
- **Dynamic pricing management** - How to set and update rates
- **Extendible product setup** - Creating and configuring partial payment products
- **Extension workflow management** - Setting up automated reminders and processing
- **Underwriter pricing strategies** - Creating competitive rate structures
- **Bulk pricing operations** - Mass updates and template imports
- **System overview and navigation** - Finding and managing pricing data
- **Managing categories and subcategories** with pricing implications
- **Pricing analytics and reporting** - Understanding market competitiveness
- **User and agent management** with pricing access controls
- **Quotation and policy management** with pricing insights
- **Extension tracking and customer follow-up** - Managing partial payment customers
- **Reminder system configuration** - Setting up SMS, email, and app notifications
- **Certificate and cover note generation** - Document management for extendible products
- **System monitoring and maintenance** for pricing integrity
- **Troubleshooting common pricing issues** and data validation
- **Extendible product troubleshooting** - Common extension and reminder issues