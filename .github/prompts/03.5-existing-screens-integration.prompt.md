---
mode: agent
title: "Integrate Services Into Existing Motor Screens"
phase: "Frontend Phase 1.5"
priority: "high"
dependencies: ["03-frontend-services", "02-api-endpoints"]
---

# Task: Adapt Existing Motor Screens (No New Screens)

## Objective

Refactor the existing motor quotation screens under `frontend/screens/quotations/motor/` to use the new centralized service layer and context from 03 without creating additional screens. Keep the current navigation and visual structure, while adding the dynamic behaviors, real-time pricing, and comparison capabilities.

## Constraints

- Do NOT create new screens or routes. Reuse and adapt:
  - `frontend/screens/quotations/motor/MotorInsuranceFormScreen.js`
  - `frontend/screens/quotations/motor/MotorInsuranceGridScreen.js`
  - `frontend/screens/quotations/motor/forms/MotorInsuranceForms.js`
  - `frontend/components/MotorInsuranceFormComponents.js`
- New UI pieces must be added as components under `frontend/components/` and imported into the existing screens.
- Preserve current UX where possible; enhance with real-time pricing, validation, and comparison.

## Target Integration Points

- Use `MotorInsuranceContext` for state and actions.
- Use `MotorInsurancePricingService` via context actions (already wired in 03).
- Use validation utilities from `utils/motorInsuranceValidation`.
- Use pricing helpers from `utils/pricingCalculations`.

## Implementation Steps

### 1) Provider Verification

- Confirm `MotorInsuranceProvider` wraps the app in `frontend/App.js`.
- If not present, wrap `<AppNavigator />` with `MotorInsuranceProvider`.

### 2) Wire Up Form Screen

- File: `frontend/screens/quotations/motor/MotorInsuranceFormScreen.js`
- Replace local form state with context values:
  - Read from `state.vehicleDetails`, `state.pricingInputs`, `state.clientDetails`, `state.calculatedPremium`, `state.formValidation`, `state.isLoading`.
  - Update via `actions.updateVehicleDetails`, `actions.updatePricingInputs` (triggers debounced calc), `actions.updateClientDetails`.
- On step change, call `actions.setCurrentStep(step)`.
- On submit, call `await actions.submitQuotation()` and handle success flow.
- Show validation errors from `state.formValidation` per field.
- Render live premium via `state.calculatedPremium` with levies breakdown.

### 3) Category/Grid Screen Adaptation

- File: `frontend/screens/quotations/motor/MotorInsuranceGridScreen.js`
- On category/subcategory selection, call `actions.setCategorySelection({ category, subcategory, productType })`.
- Navigate to the existing `MotorInsuranceFormScreen` as done today.
- Preload underwriters with `await actions.loadUnderwriters()` after selection to warm cache.

### 4) Dynamic Field Binding

- File: `frontend/screens/quotations/motor/forms/MotorInsuranceForms.js`
- Bind each field to context:
  - Vehicle fields -> `actions.updateVehicleDetails({ fieldName: value })`
  - Pricing fields -> `actions.updatePricingInputs({ fieldName: value })` (auto-debounced calc)
- Read field errors from `state.formValidation[fieldName]`.
- For comprehensive products, include `sum_insured`, `excess_protector`, `pvt` controls and ensure validation boundaries are enforced.

### 5) Comparison Integration (Inline)

- Within `MotorInsuranceFormScreen` (or its child component):
  - Render a comparison section that lists `state.pricingComparison`.
  - Trigger with `await actions.comparePricing(selectedUnderwriterIds)` after underwriters are loaded.
  - Allow selecting an underwriter via `actions.setSelectedUnderwriter(underwriter)`.

### 6) Error & Loading States

- Drive spinners and disabled states from `state.isLoading`.
- Show friendly error messages from `state.errors.pricing`, `state.errors.comparison`, `state.errors.submit`.

### 7) Optional UI Components (Reused, Not New Screens)

Create these components under `frontend/components/` and import them into existing screens:

- `PremiumCalculationDisplay` – shows base, ITL, PCF, stamp, total using `state.calculatedPremium`.
- `UnderwriterComparisonView` – table/cards for `state.pricingComparison` with sort by price.
- `PremiumBreakdownCard` – expandable cost details using `pricingCalculations` helpers.
- `AdditionalCoverageSelector` – toggles for comprehensive add-ons.

### 8) Cleanup & Migration

- Remove any direct API calls inside screens that duplicate DjangoAPIService usage; replace with context actions.
- Remove ad-hoc debouncing; rely on context `debouncedCalculate` via `updatePricingInputs`.
- Ensure no duplicate local validation remains; consolidate to `motorInsuranceValidation` results from context.

## Success Criteria

- [ ] Existing motor screens function without new screens/routes.
- [ ] Real-time premium updates as inputs change.
- [ ] Comparison view works and selects an underwriter.
- [ ] Validation messages appear per field and gate navigation.
- [ ] Loading and error states are consistently managed via context.
- [ ] No direct backend calls in screens (only via context/service).
- [ ] No regression in navigation or layout.

## File Touch List (No New Screens)

- Modify:
  - `frontend/screens/quotations/motor/MotorInsuranceFormScreen.js`
  - `frontend/screens/quotations/motor/MotorInsuranceGridScreen.js`
  - `frontend/screens/quotations/motor/forms/MotorInsuranceForms.js`
  - `frontend/components/MotorInsuranceFormComponents.js`
- Add (components only, imported by screens):
  - `frontend/components/PremiumCalculationDisplay.js`
  - `frontend/components/UnderwriterComparisonView.js`
  - `frontend/components/PremiumBreakdownCard.js`
  - `frontend/components/AdditionalCoverageSelector.js`

## Testing

- Add quick component tests where feasible under `frontend/testing/`.
- Manual flow:
  - Select category/subcategory -> form -> live premium -> compare -> select underwriter -> submit.
- Verify offline fallback shows last cached premium and cached underwriters where applicable.

## Notes

- Keep UI minimal changes; focus on connecting to context and services from 03.
- If an existing `useMotorInsuranceForm` hook exists, migrate it to read/write through `MotorInsuranceContext` or remove redundant logic to avoid double state.
